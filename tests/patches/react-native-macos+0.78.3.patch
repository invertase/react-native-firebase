diff --git a/node_modules/react-native-macos/Libraries/Blob/BlobManager.js b/node_modules/react-native-macos/Libraries/Blob/BlobManager.js
index f4c5ed3..f7afaf4 100644
--- a/node_modules/react-native-macos/Libraries/Blob/BlobManager.js
+++ b/node_modules/react-native-macos/Libraries/Blob/BlobManager.js
@@ -9,7 +9,7 @@
  */
 
 import type {BlobCollector, BlobData, BlobOptions} from './BlobTypes';
-
+import {fromByteArray} from 'base64-js';
 import NativeBlobModule from './NativeBlobModule';
 import invariant from 'invariant';
 
@@ -67,9 +67,11 @@ class BlobManager {
     const blobId = uuidv4();
     const items = parts.map(part => {
       if (part instanceof ArrayBuffer || ArrayBuffer.isView(part)) {
-        throw new Error(
-          "Creating blobs from 'ArrayBuffer' and 'ArrayBufferView' are not supported",
-        );
+        return {
+          // $FlowFixMe[incompatible-cast]
+          data: fromByteArray(new Uint8Array((part))),
+          type: 'string',
+        };
       }
       if (part instanceof Blob) {
         return {
@@ -92,6 +94,7 @@ class BlobManager {
     }, 0);
 
     NativeBlobModule.createFromParts(items, blobId);
+    // console.error('BlobManager thinks blob id ' + blobId + ' already exists (but it may not yet on iOS!).');
 
     return BlobManager.createFromOptions({
       blobId,
diff --git a/node_modules/react-native-macos/Libraries/Blob/RCTBlobManager.mm b/node_modules/react-native-macos/Libraries/Blob/RCTBlobManager.mm
index 9d4cde7..c9e6a81 100755
--- a/node_modules/react-native-macos/Libraries/Blob/RCTBlobManager.mm
+++ b/node_modules/react-native-macos/Libraries/Blob/RCTBlobManager.mm
@@ -95,6 +95,7 @@ RCT_EXPORT_MODULE(BlobModule)
 - (void)store:(NSData *)data withId:(NSString *)blobId
 {
   std::lock_guard<std::mutex> lock(_blobsMutex);
+  //RCTLogError(@"RCTBlobManager store inside mutex storing blob id %@", blobId);
   _blobs[blobId] = data;
 }
 
@@ -117,9 +118,13 @@ RCT_EXPORT_MODULE(BlobModule)
   NSData *data;
   {
     std::lock_guard<std::mutex> lock(_blobsMutex);
+    // FIXME Right here it seems the blob does not exist for some reason?
+    //RCTLogError(@"RCTBlobManager resolve inside mutex resolving blob id %@", blobId);
     data = _blobs[blobId];
   }
   if (!data) {
+    // FIXME and we return nil to handleNetworkingRequest which then crashes
+    //RCTLogError(@"RCTBlobManager resolve no data for blob id %@", blobId);
     return nil;
   }
   if (offset != 0 || (size != -1 && size != data.length)) {
@@ -156,6 +161,7 @@ RCT_EXPORT_MODULE(BlobModule)
 - (void)remove:(NSString *)blobId
 {
   std::lock_guard<std::mutex> lock(_blobsMutex);
+  //RCTLogError(@"RCTBlobManager remove inside mutex removing blob id %@", blobId);
   [_blobs removeObjectForKey:blobId];
 }
 
@@ -217,15 +223,19 @@ RCT_EXPORT_METHOD(createFromParts : (NSArray<NSDictionary<NSString *, id> *> *)p
     }
   }
 
+  //RCTLogError(@"RCTBlobManager createFromParts requesting store of blob id %@", blobId);
   dispatch_async([self executionQueue], ^{
     [self store:data withId:blobId];
+    //RCTLogError(@"RCTBlobManager createFromParts done storing blob id %@", blobId);
   });
 }
 
 RCT_EXPORT_METHOD(release : (NSString *)blobId)
 {
+  //RCTLogError(@"RCTBlobManager enqueueing release of blob id %@", blobId);
   dispatch_async([self executionQueue], ^{
     [self remove:blobId];
+    //RCTLogError(@"RCTBlobManager done releasing blob id %@", blobId);
   });
 }
 
@@ -297,13 +307,30 @@ RCT_EXPORT_METHOD(release : (NSString *)blobId)
   // @lint-ignore FBOBJCUNTYPEDCOLLECTION1
   NSDictionary *blob = [RCTConvert NSDictionary:data[@"blob"]];
   
+  // FIXME so here - we checked that data[@"blob"] was non-nil in canHandleHandleNetworkingRequest
+
   NSString *contentType = @"application/octet-stream";
   NSString *blobType = [RCTConvert NSString:RCTNilIfNull(blob[@"type"])];
   if (blobType != nil && blobType.length > 0) {
     contentType = blob[@"type"];
   }
 
-  return @{@"body" : [self resolve:blob], @"contentType" : contentType};
+  // FIXME but here in resolve:blob the blob isn't found somehow? comes back nil?
+  NSData *blobBody = nil;
+  NSString *blobId = nil;
+  for (int retries = 0; blobBody == nil && retries < 100; retries++) {
+    blobBody = [self resolve:blob];
+    if (blobBody == nil) {
+      if (blobId == nil) {
+        blobId = [RCTConvert NSString:blob[@"blobId"]];
+      }
+      //RCTLogError(@"RCTBlobManager handleNetworkingRequest nil blobBody for blob id %@", blobId);
+      //RCTLogError(@"RCTBlobManager handleNetworkingRequest, sleeping for blob id %@", blobId);
+      [NSThread sleepForTimeInterval:0.1f];
+    }
+  }
+
+  return @{@"body" : blobBody, @"contentType" : contentType};
 }
 
 - (BOOL)canHandleNetworkingResponse:(NSString *)responseType
diff --git a/node_modules/react-native-macos/Libraries/Network/RCTNetworking.mm b/node_modules/react-native-macos/Libraries/Network/RCTNetworking.mm
index 80d8c30..b68a67e 100644
--- a/node_modules/react-native-macos/Libraries/Network/RCTNetworking.mm
+++ b/node_modules/react-native-macos/Libraries/Network/RCTNetworking.mm
@@ -417,9 +417,19 @@ RCT_EXPORT_MODULE()
   for (id<RCTNetworkingRequestHandler> handler in _requestHandlers) {
     if ([handler canHandleNetworkingRequest:query]) {
       // @lint-ignore FBOBJCUNTYPEDCOLLECTION1
-      NSDictionary *body = [handler handleNetworkingRequest:query];
-      if (body) {
-        return callback(nil, body);
+      NSDictionary *blob = [RCTConvert NSDictionary:query[@"blob"]];
+      NSString *blobId = [RCTConvert NSString:blob[@"blobId"]];
+      try {
+        //RCTLogError(@"RCTNetworking process handling blob id %@", blobId);
+        NSDictionary *body = [handler handleNetworkingRequest:query];
+        if (body) {
+          return callback(nil, body);
+        }
+      } catch (NSException *exception) {
+        //RCTLogError(@"RCTNetworking process blob id %@ caught %@ because %@", blobId, exception.name, exception.reason);
+        NSError *error = [[NSError alloc] initWithDomain:NSURLErrorDomain code:NSURLErrorUnknown userInfo:nil];
+        //RCTLogError(@"RCTNetworking process blob id %@ returning error to callback.", blobId);
+        return callback(error, nil);
       }
     }
   }
